import fs from "node:fs"; import readline from "node:readline"; import dotenv from "dotenv"; dotenv.config({ path: fs.existsSync(".env.local") ? ".env.local" : ".env" }); import { PrismaClient } from "@prisma/client"; const prisma = new PrismaClient(); const ADMIN_EMAILS = (process.env.ADMIN_EMAILS ?? "demo@med.ai").split(",").map(s=>s.toLowerCase().trim()).filter(Boolean); if (ADMIN_EMAILS.length === 0) { console.error("ERROR: ADMIN_EMAILS env is required (comma-separated). Example: demo@med.ai"); process.exit(1); } const KEEP = ADMIN_EMAILS[0]; const DRY = process.env.DRY_RUN === "1"; const FORCE = process.env.FORCE_DELETE === "1"; function ask(q){ return new Promise(res=>{ const rl=readline.createInterface({input:process.stdin,output:process.stdout}); rl.question(q, a=>{ rl.close(); res(a.trim()); }); }); } function mask(e){ const [u,dom] = e.split("@"); return u?.slice(0,2)+"***@"+dom; } async function main(){ const prodGuard = process.env.CONFIRM_PRODUCTION !== "I_UNDERSTAND"; console.log("KEEP (demo):", KEEP, "(masked:", mask(KEEP), ")"); const users = await prisma.user.findMany({ select: { id:true, email:true }}); const victims = users.filter(u=>u.email.toLowerCase()!==KEEP); console.log("Total users:", users.length, "Will delete:", victims.length); if (DRY) { console.log("DRY-RUN: no changes will be applied."); console.log("Users to delete:", victims.map(v => v.email).join(", ")); return; } if (FORCE) { console.log("FORCE mode: skipping confirmations"); } else { const confirm1 = await ask(`Type the email to keep exactly ("${KEEP}") to proceed: `); if (confirm1.toLowerCase() !== KEEP) { console.error("Confirmation mismatch. Abort."); process.exit(1); } console.log("Will delete:", victims.map(v => v.email).join(", ")); const confirm2 = await ask("Type YES to delete all other users: "); if (confirm2 !== "YES") { console.error("Abort."); process.exit(1); } } if (prodGuard) { console.log("Add CONFIRM_PRODUCTION=I_UNDERSTAND to env to run without guard."); process.exit(1); } console.log("Starting deletion..."); try { console.log("Deleting related data..."); for (const victim of victims) { console.log(`Deleting data for user: ${victim.email}`); await prisma.answerLog.deleteMany({ where: { session: { userId: victim.id } } }); await prisma.studySession.deleteMany({ where: { userId: victim.id } }); await prisma.dailyUsage.deleteMany({ where: { userId: victim.id } }); await prisma.like.deleteMany({ where: { userId: victim.id } }); await prisma.bookmark.deleteMany({ where: { userId: victim.id } }); await prisma.card.deleteMany({ where: { cardSet: { ownerId: victim.id } } }); await prisma.cardSet.deleteMany({ where: { ownerId: victim.id } }); await prisma.doc.deleteMany({ where: { ownerId: victim.id } }); } console.log("Deleting users..."); await prisma.user.deleteMany({ where: { email: { not: KEEP } } }); console.log("Done. Remaining user(s):", await prisma.user.count()); } catch (error) { console.error("Error during deletion:", error); process.exit(1); } } main().then(()=>process.exit(0)).catch(e=>{ console.error(e); process.exit(1); });
